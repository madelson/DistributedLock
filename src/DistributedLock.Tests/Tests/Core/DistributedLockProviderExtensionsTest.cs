using Moq;
using NUnit.Framework;
using System.Linq.Expressions;

namespace Medallion.Threading.Tests.Core;

// Note: we don't bother testing the extensions for the other providers since they are all auto-generated by the same component.
public class DistributedLockProviderExtensionsTest
{
    [Test]
    public void TestArgumentValidation()
    {
        Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.TryAcquireLockAsync(null!, "name"));
        Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.TryAcquireLock(null!, "name"));
        Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.AcquireLockAsync(null!, "name"));
        Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.AcquireLock(null!, "name"));
    }

    [Test, Combinatorial]
    public void TestCallThrough([Values] bool isTry, [Values] bool isAsync)
    {
        var mockLock = new Mock<IDistributedLock>();
        var mockProvider = new Mock<IDistributedLockProvider>();
        mockProvider.Setup(p => p.CreateLock("name"))
            .Returns(mockLock.Object)
            .Verifiable();

        if (isTry)
        {
            if (isAsync)
            {
                Test(p => p.TryAcquireLockAsync("name", default, default), l => l.TryAcquireAsync(default, default));
            }
            else
            {
                Test(p => p.TryAcquireLock("name", default, default), l => l.TryAcquire(default, default));
            }
        }
        else
        {
            if (isAsync)
            {
                Test(p => p.AcquireLockAsync("name", default, default), l => l.AcquireAsync(default, default));
            }
            else
            {
                Test(p => p.AcquireLock("name", default, default), l => l.Acquire(default, default));
            }
        }

        void Test<TResult>(
            Expression<Func<IDistributedLockProvider, TResult>> providerFunction,
            Expression<Func<IDistributedLock, TResult>> lockFunction)
        {
            providerFunction.Compile()(mockProvider.Object);

            mockProvider.Verify(p => p.CreateLock("name"), Times.Once);
            mockLock.Verify(lockFunction, Times.Once());
        }
    }

    [Test, Combinatorial]
    public void TestCompositeArgumentValidation([Values] bool isAsync)
    {
        var mockProvider = new Mock<IDistributedLockProvider>();
        var validNames = new List<string> { "lock1", "lock2" };

        if (isAsync)
        {
            Assert.ThrowsAsync<ArgumentNullException>(() => DistributedLockProviderExtensions.TryAcquireAllLocksAsync(null!, validNames).AsTask());
            Assert.ThrowsAsync<ArgumentNullException>(() => DistributedLockProviderExtensions.TryAcquireAllLocksAsync(mockProvider.Object, null!).AsTask());
            Assert.ThrowsAsync<ArgumentException>(() => DistributedLockProviderExtensions.TryAcquireAllLocksAsync(mockProvider.Object, new List<string>()).AsTask());
            Assert.ThrowsAsync<ArgumentException>(() => DistributedLockProviderExtensions.TryAcquireAllLocksAsync(mockProvider.Object, new List<string> { "lock1", null! }).AsTask());

            Assert.ThrowsAsync<ArgumentNullException>(() => DistributedLockProviderExtensions.AcquireAllLocksAsync(null!, validNames).AsTask());
            Assert.ThrowsAsync<ArgumentNullException>(() => DistributedLockProviderExtensions.AcquireAllLocksAsync(mockProvider.Object, null!).AsTask());
            Assert.ThrowsAsync<ArgumentException>(() => DistributedLockProviderExtensions.AcquireAllLocksAsync(mockProvider.Object, new List<string>()).AsTask());
            Assert.ThrowsAsync<ArgumentException>(() => DistributedLockProviderExtensions.AcquireAllLocksAsync(mockProvider.Object, new List<string> { "lock1", null! }).AsTask());
        }
        else
        {
            Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.TryAcquireAllLocks(null!, validNames));
            Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.TryAcquireAllLocks(mockProvider.Object, null!));
            Assert.Throws<ArgumentException>(() => DistributedLockProviderExtensions.TryAcquireAllLocks(mockProvider.Object, new List<string>()));
            Assert.Throws<ArgumentException>(() => DistributedLockProviderExtensions.TryAcquireAllLocks(mockProvider.Object, new List<string> { "lock1", null! }));

            Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.AcquireAllLocks(null!, validNames));
            Assert.Throws<ArgumentNullException>(() => DistributedLockProviderExtensions.AcquireAllLocks(mockProvider.Object, null!));
            Assert.Throws<ArgumentException>(() => DistributedLockProviderExtensions.AcquireAllLocks(mockProvider.Object, new List<string>()));
            Assert.Throws<ArgumentException>(() => DistributedLockProviderExtensions.AcquireAllLocks(mockProvider.Object, new List<string> { "lock1", null! }));
        }
    }

    [Test, Combinatorial]
    public async Task TestCompositePartialAcquisitionFailure([Values] bool isAsync)
    {
        var mockProvider = new Mock<IDistributedLockProvider>();
        var mockLockA = new Mock<IDistributedLock>();
        var mockLockB = new Mock<IDistributedLock>();
        var mockHandleA = new Mock<IDistributedSynchronizationHandle>();

        mockProvider.Setup(p => p.CreateLock("A")).Returns(mockLockA.Object);
        mockProvider.Setup(p => p.CreateLock("B")).Returns(mockLockB.Object);

        if (isAsync)
        {
            mockLockA.Setup(l => l.TryAcquireAsync(TimeSpan.Zero, default))
                .ReturnsAsync(mockHandleA.Object);
            mockLockB.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
                .ReturnsAsync((IDistributedSynchronizationHandle?)null);
        }
        else
        {
            mockLockA.Setup(l => l.TryAcquire(TimeSpan.Zero, default))
                .Returns(mockHandleA.Object);
            mockLockB.Setup(l => l.TryAcquire(It.IsAny<TimeSpan>(), default))
                .Returns((IDistributedSynchronizationHandle?)null);
        }

        var names = new List<string> { "A", "B" };
        IDistributedSynchronizationHandle? result;

        if (isAsync)
        {
            result = await mockProvider.Object.TryAcquireAllLocksAsync(names, TimeSpan.Zero, default);
        }
        else
        {
            result = mockProvider.Object.TryAcquireAllLocks(names, TimeSpan.Zero, default);
        }

        Assert.That(result, Is.Null);

        mockHandleA.Verify(h => h.DisposeAsync(), Times.Once);
    }

    [Test, Combinatorial]
    public async Task TestCompositeSuccessfulAcquisition([Values] bool isTry, [Values] bool isAsync)
    {
        var mockProvider = new Mock<IDistributedLockProvider>();
        var mockLockA = new Mock<IDistributedLock>();
        var mockLockB = new Mock<IDistributedLock>();
        var mockHandleA = new Mock<IDistributedSynchronizationHandle>();
        var mockHandleB = new Mock<IDistributedSynchronizationHandle>();

        mockProvider.Setup(p => p.CreateLock("A")).Returns(mockLockA.Object);
        mockProvider.Setup(p => p.CreateLock("B")).Returns(mockLockB.Object);

        if (isAsync)
        {
            if (isTry)
            {
                mockLockA.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
                    .ReturnsAsync(mockHandleA.Object);
                mockLockB.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
                    .ReturnsAsync(mockHandleB.Object);
            }
            else
            {
                mockLockA.Setup(l => l.AcquireAsync(It.IsAny<TimeSpan?>(), default))
                    .ReturnsAsync(mockHandleA.Object);
                mockLockB.Setup(l => l.AcquireAsync(It.IsAny<TimeSpan?>(), default))
                    .ReturnsAsync(mockHandleB.Object);
            }
        }
        else
        {
            if (isTry)
            {
                mockLockA.Setup(l => l.TryAcquire(It.IsAny<TimeSpan>(), default))
                    .Returns(mockHandleA.Object);
                mockLockB.Setup(l => l.TryAcquire(It.IsAny<TimeSpan>(), default))
                    .Returns(mockHandleB.Object);
            }
            else
            {
                mockLockA.Setup(l => l.Acquire(It.IsAny<TimeSpan?>(), default))
                    .Returns(mockHandleA.Object);
                mockLockB.Setup(l => l.Acquire(It.IsAny<TimeSpan?>(), default))
                    .Returns(mockHandleB.Object);
            }
        }

        var names = new List<string> { "A", "B" };
        IDistributedSynchronizationHandle? result;

        if (isAsync)
        {
            if (isTry)
            {
                result = await mockProvider.Object.TryAcquireAllLocksAsync(names, TimeSpan.FromSeconds(10), default);
            }
            else
            {
                result = await mockProvider.Object.AcquireAllLocksAsync(names, TimeSpan.FromSeconds(10), default);
            }
        }
        else
        {
            if (isTry)
            {
                result = mockProvider.Object.TryAcquireAllLocks(names, TimeSpan.FromSeconds(10), default);
            }
            else
            {
                result = mockProvider.Object.AcquireAllLocks(names, TimeSpan.FromSeconds(10), default);
            }
        }

        Assert.That(result, Is.Not.Null);

        mockProvider.Verify(p => p.CreateLock("A"), Times.Once);
        mockProvider.Verify(p => p.CreateLock("B"), Times.Once);

        if (isAsync)
        {
            await result!.DisposeAsync();
            mockHandleA.Verify(h => h.DisposeAsync(), Times.Once);
            mockHandleB.Verify(h => h.DisposeAsync(), Times.Once);
        }
        else
        {
            result!.Dispose();
            mockHandleA.Verify(h => h.Dispose(), Times.Once);
            mockHandleB.Verify(h => h.Dispose(), Times.Once);
        }
    }

    [Test, Combinatorial]
    public void TestCompositeAcquireThrowsOnTimeout([Values] bool isAsync)
    {
        var mockProvider = new Mock<IDistributedLockProvider>();
        var mockLockA = new Mock<IDistributedLock>();

        mockProvider.Setup(p => p.CreateLock("A")).Returns(mockLockA.Object);

        if (isAsync)
        {
            mockLockA.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
                .ReturnsAsync((IDistributedSynchronizationHandle?)null);
        }
        else
        {
            mockLockA.Setup(l => l.TryAcquire(It.IsAny<TimeSpan>(), default))
                .Returns((IDistributedSynchronizationHandle?)null);
        }

        var names = new List<string> { "A" };

        if (isAsync)
        {
            Assert.ThrowsAsync<TimeoutException>(() => mockProvider.Object.AcquireAllLocksAsync(names, TimeSpan.Zero, default).AsTask());
        }
        else
        {
            Assert.Throws<TimeoutException>(() => mockProvider.Object.AcquireAllLocks(names, TimeSpan.Zero, default));
        }
    }

    [Test]
    public async Task TestCompositeRemainingTimeDistribution()
    {
        var mockProvider = new Mock<IDistributedLockProvider>();
        var mockLockA = new Mock<IDistributedLock>();
        var mockLockB = new Mock<IDistributedLock>();
        var mockHandleA = new Mock<IDistributedSynchronizationHandle>();
        var mockHandleB = new Mock<IDistributedSynchronizationHandle>();

        mockProvider.Setup(p => p.CreateLock("A")).Returns(mockLockA.Object);
        mockProvider.Setup(p => p.CreateLock("B")).Returns(mockLockB.Object);

        var capturedTimeouts = new List<TimeSpan>();

        mockLockA.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
            .ReturnsAsync((TimeSpan timeout, CancellationToken _) =>
            {
                capturedTimeouts.Add(timeout);
                Task.Delay(TimeSpan.FromMilliseconds(100)).Wait();
                return mockHandleA.Object;
            });

        mockLockB.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
            .ReturnsAsync((TimeSpan timeout, CancellationToken _) =>
            {
                capturedTimeouts.Add(timeout);
                return mockHandleB.Object;
            });

        var names = new List<string> { "A", "B" };
        var totalTimeout = TimeSpan.FromSeconds(5);

        var result = await mockProvider.Object.TryAcquireAllLocksAsync(names, totalTimeout, default);

        Assert.That(result, Is.Not.Null);
        Assert.That(capturedTimeouts.Count, Is.EqualTo(2));

        Assert.That(capturedTimeouts[0].TotalMilliseconds, Is.EqualTo(totalTimeout.TotalMilliseconds).Within(1.0));

        Assert.That(capturedTimeouts[1], Is.LessThan(totalTimeout));
        Assert.That(capturedTimeouts[1], Is.GreaterThanOrEqualTo(TimeSpan.Zero));

        await result!.DisposeAsync();
    }

    [Test]
    public async Task TestCompositeHandleLostToken()
    {
        var mockProvider = new Mock<IDistributedLockProvider>();
        var mockLockA = new Mock<IDistributedLock>();
        var mockLockB = new Mock<IDistributedLock>();

        var ctsA = new CancellationTokenSource();
        var ctsB = new CancellationTokenSource();

        var mockHandleA = new Mock<IDistributedSynchronizationHandle>();
        var mockHandleB = new Mock<IDistributedSynchronizationHandle>();

        mockHandleA.Setup(h => h.HandleLostToken).Returns(ctsA.Token);
        mockHandleB.Setup(h => h.HandleLostToken).Returns(ctsB.Token);

        mockProvider.Setup(p => p.CreateLock("A")).Returns(mockLockA.Object);
        mockProvider.Setup(p => p.CreateLock("B")).Returns(mockLockB.Object);

        mockLockA.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
            .ReturnsAsync(mockHandleA.Object);
        mockLockB.Setup(l => l.TryAcquireAsync(It.IsAny<TimeSpan>(), default))
            .ReturnsAsync(mockHandleB.Object);

        var names = new List<string> { "A", "B" };
        var result = await mockProvider.Object.TryAcquireAllLocksAsync(names, TimeSpan.FromSeconds(10), default);

        Assert.That(result, Is.Not.Null);
        Assert.That(result!.HandleLostToken.CanBeCanceled, Is.True);

        ctsA.Cancel();

        Assert.That(result.HandleLostToken.IsCancellationRequested, Is.True);

        await result.DisposeAsync();
        ctsA.Dispose();
        ctsB.Dispose();
    }
}
